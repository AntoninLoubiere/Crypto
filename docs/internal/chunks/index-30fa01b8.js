var Y=Object.defineProperty,H=Object.defineProperties;var Z=Object.getOwnPropertyDescriptors;var S=Object.getOwnPropertySymbols;var J=Object.prototype.hasOwnProperty,Q=Object.prototype.propertyIsEnumerable;var M=(e,t,r)=>t in e?Y(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,B=(e,t)=>{for(var r in t||(t={}))J.call(t,r)&&M(e,r,t[r]);if(S)for(var r of S(t))Q.call(t,r)&&M(e,r,t[r]);return e},T=(e,t)=>H(e,Z(t));const X=(e,t)=>t.some(r=>e instanceof r);let P,L;function z(){return P||(P=[IDBDatabase,IDBObjectStore,IDBIndex,IDBCursor,IDBTransaction])}function q(){return L||(L=[IDBCursor.prototype.advance,IDBCursor.prototype.continue,IDBCursor.prototype.continuePrimaryKey])}const C=new WeakMap,p=new WeakMap,_=new WeakMap,m=new WeakMap,I=new WeakMap;function ee(e){const t=new Promise((r,n)=>{const a=()=>{e.removeEventListener("success",c),e.removeEventListener("error",s)},c=()=>{r(u(e.result)),a()},s=()=>{n(e.error),a()};e.addEventListener("success",c),e.addEventListener("error",s)});return t.then(r=>{r instanceof IDBCursor&&C.set(r,e)}).catch(()=>{}),I.set(t,e),t}function te(e){if(p.has(e))return;const t=new Promise((r,n)=>{const a=()=>{e.removeEventListener("complete",c),e.removeEventListener("error",s),e.removeEventListener("abort",s)},c=()=>{r(),a()},s=()=>{n(e.error||new DOMException("AbortError","AbortError")),a()};e.addEventListener("complete",c),e.addEventListener("error",s),e.addEventListener("abort",s)});p.set(e,t)}let K={get(e,t,r){if(e instanceof IDBTransaction){if(t==="done")return p.get(e);if(t==="objectStoreNames")return e.objectStoreNames||_.get(e);if(t==="store")return r.objectStoreNames[1]?void 0:r.objectStore(r.objectStoreNames[0])}return u(e[t])},set(e,t,r){return e[t]=r,!0},has(e,t){return e instanceof IDBTransaction&&(t==="done"||t==="store")?!0:t in e}};function re(e){K=e(K)}function ne(e){return e===IDBDatabase.prototype.transaction&&!("objectStoreNames"in IDBTransaction.prototype)?function(t,...r){const n=e.call(E(this),t,...r);return _.set(n,t.sort?t.sort():[t]),u(n)}:q().includes(e)?function(...t){return e.apply(E(this),t),u(C.get(this))}:function(...t){return u(e.apply(E(this),t))}}function ae(e){return typeof e=="function"?ne(e):(e instanceof IDBTransaction&&te(e),X(e,z())?new Proxy(e,K):e)}function u(e){if(e instanceof IDBRequest)return ee(e);if(m.has(e))return m.get(e);const t=ae(e);return t!==e&&(m.set(e,t),I.set(t,e)),t}const E=e=>I.get(e);function ce(e,t,{blocked:r,upgrade:n,blocking:a,terminated:c}={}){const s=indexedDB.open(e,t),o=u(s);return n&&s.addEventListener("upgradeneeded",i=>{n(u(s.result),i.oldVersion,i.newVersion,u(s.transaction))}),r&&s.addEventListener("blocked",()=>r()),o.then(i=>{c&&i.addEventListener("close",()=>c()),a&&i.addEventListener("versionchange",()=>a())}).catch(()=>{}),o}const se=["get","getKey","getAll","getAllKeys","count"],oe=["put","add","delete","clear"],b=new Map;function v(e,t){if(!(e instanceof IDBDatabase&&!(t in e)&&typeof t=="string"))return;if(b.get(t))return b.get(t);const r=t.replace(/FromIndex$/,""),n=t!==r,a=oe.includes(r);if(!(r in(n?IDBIndex:IDBObjectStore).prototype)||!(a||se.includes(r)))return;const c=async function(s,...o){const i=this.transaction(s,a?"readwrite":"readonly");let y=i.store;return n&&(y=y.index(o.shift())),(await Promise.all([y[r](...o),a&&i.done]))[0]};return b.set(t,c),c}re(e=>T(B({},e),{get:(t,r,n)=>v(t,r)||e.get(t,r,n),has:(t,r)=>!!v(t,r)||e.has(t,r)}));const ie=1;let A;async function g(){return A||(A=await ce("crypto-db",ie,{upgrade(e,t){t<1&&e.createObjectStore("cryptoKeys",{keyPath:"keyId",autoIncrement:!0})}})),A}function ue(e){return e>64&&e<91?e-65:e>96&&e<123?e-71:e>47&&e<58?e+4:e===43?62:e===47?63:0}function U(e,t){const r=e.replace(/[^A-Za-z0-9+/]/g,""),n=r.length,a=t?Math.ceil((n*3+1>>2)/t)*t:n*3+1>>2,c=new Uint8Array(a);for(let s,o,i=0,y=0,f=0;f<n;f++)if(o=f&3,i|=ue(r.charCodeAt(f))<<6*(3-o),o===3||n-f===1){for(s=0;s<3&&y<a;s++,y++)c[y]=i>>>(16>>>s&24)&255;i=0}return c}function w(e){return e<26?e+65:e<52?e+71:e<62?e-4:e===62?43:e===63?47:65}function D(e){let t=2,r="";for(let n=e.length,a=0,c=0;c<n;c++)t=c%3,c>0&&c*4/3%76===0&&(r+=`\r
`),a|=e[c]<<(16>>>t&24),(t===2||e.length-c===1)&&(r+=String.fromCodePoint(w(a>>>18&63),w(a>>>12&63),w(a>>>6&63),w(a&63)),a=0);return r.substr(0,r.length-2+t)+(t===2?"":t===1?"=":"==")}class d extends Error{constructor(t,r,n){super((n?n+" - ":"")+t+" - "+r),this.name="CryptoError"}}const N=`-----BEGIN PRIVATE KEY-----
`,G=`
-----END PRIVATE KEY-----`,j=`-----BEGIN PUBLIC KEY-----
`,V=`
-----END PUBLIC KEY-----`;function k(e,t,r){if(!e)throw new d("wrong_key",`${r} does not support this type of key for ${t}.`,r);if(e.algorithm.name!=r)throw new d("wrong_key",`This key isn't made for ${r} but for ${e.algorithm.name}.`);if(!e.usages.includes(t))throw new d("wrong_key_usage",`This key does not support ${t}.`,r);return e}function x(e,t,...r){const n=Math.ceil(t/8),a=[];for(let o=0;o<n;o++)a.push(e>>8*o&255);const c=$(...r),s=new Uint8Array(c.length+n);return s.set(a),s.set(c,n),s}function $(...e){const t=e.reduce((a,c)=>a+c.length+Math.ceil(de(c.length)/7),0),r=new Uint8Array(t);let n=0;for(const a of e){let c=a.length;const s=[];do{let o=c&127;c>>=7,c>0&&(o|=128),s.push(o)}while(c>0);r.set(s,n),n+=s.length,r.set(a,n),n+=a.length}return console.assert(n==t,"We should have added the whole length",{offset:n,length:t,arrays:e}),r}function ye(e,t){const r=Math.ceil(e/8);let n=0;for(let c=0;c<r;c++){const s=t.at(c);!s||(n|=s<<8*c)}const a=F(t.slice(r));return{flags:n,arrays:a}}function F(e){const t=[];let r=0;for(;r<e.length;){let n=0,a,c=0;do{if(a=e.at(r),r+=1,!a)break;n|=(a&127)<<7*c++}while((a&128)==128);if(n+r>e.length)break;t.push(e.slice(r,r+n)),r+=n}if(r!=e.length)throw new d("malformed_data","The data to split is malformed.");return t}function de(e){return e?Math.floor(Math.log2(e)+1):1}function R(e,t){const r=e=="pem"?N.trim():j.trim(),n=e=="pem"?G.trim():V.trim(),a=t.search(r),c=t.search(n);if(a<0||c<0)throw new d("malformed_data",`The key given is malformed and does not meet the requirements of ${e} encoding.`);return U(t.substring(a+r.length,c))}async function le(e,t,r){const n=crypto.getRandomValues(new Uint8Array(Math.ceil(r/8))),a=await crypto.subtle.importKey("raw",n.buffer,t,!1,[e]);return{key:n,keyEncoded:a}}async function fe(e,t){const{key:r,keyEncoded:n}=await le("encrypt",(t==null?void 0:t.name)||"AES-GCM",(t==null?void 0:t.keyLength)||256),a=crypto.getRandomValues(new Uint8Array(Math.ceil(t!=null&&t.keyLength?t.keyLength/8:32))),c=(t==null?void 0:t.name)=="AES-CTR"?{name:"AES-CTR",counter:a,length:t!=null&&t.length?t==null?void 0:t.length:64}:{name:(t==null?void 0:t.name)||"AES-GCM",iv:a},s=new Uint8Array(await crypto.subtle.encrypt(c,n,e)),o=$(a,s);return{key:r,cipher:o}}async function he(e,t){const r=await crypto.subtle.importKey("raw",e.buffer,"AES-GCM",!1,["decrypt"]),[n,a]=F(t);return new Uint8Array(await crypto.subtle.decrypt({name:"AES-GCM",iv:n},r,a))}const we={async encrypt(e,t,r){const n=k(e.publicKey,"encrypt","RSA-OAEP");if((r==null?void 0:r.useSubEncrypt)==null&&(r||(r={}),r.useSubEncrypt=!!r.subEncrypt||t.length>32),r.useSubEncrypt){r.subEncrypt||(r.subEncrypt={name:"AES-GCM"});const{key:a,cipher:c}=await fe(t,r.subEncrypt),s=await crypto.subtle.encrypt(n.algorithm,n,a);return x(1,1,new Uint8Array(s),c)}else{const a=await crypto.subtle.encrypt(n.algorithm,n,t);return x(0,1,new Uint8Array(a))}},async decrypt(e,t){const r=k(e.privateKey,"decrypt","RSA-OAEP"),{flags:n,arrays:a}=ye(1,t);if(n==1){const[c,s]=a,o=new Uint8Array(await crypto.subtle.decrypt(r.algorithm,r,c));return he(o,s)}else{const[c]=a;return new Uint8Array(await crypto.subtle.decrypt(r.algorithm,r,c))}},async generateKey(e,t){const r=await crypto.subtle.generateKey({name:"RSA-OAEP",modulusLength:(t==null?void 0:t.modulus)||4096,publicExponent:new Uint8Array([1,0,1]),hash:(t==null?void 0:t.hash)||"SHA-256"},!0,(t==null?void 0:t.usages)||["encrypt","decrypt"]);return{algorithm:"RSA-OAEP",name:e,password:(t==null?void 0:t.password)||"none",privateKey:r.privateKey,publicKey:r.publicKey,creationDate:new Date,useDate:new Date}},async importKey(e,t,r){const n={name:"RSA-OAEP",modulusLength:(r==null?void 0:r.modulus)||4096,publicExponent:new Uint8Array([1,0,1]),hash:(r==null?void 0:r.hash)||"SHA-256"},a=await crypto.subtle.importKey("spki",R("spki",e.key).buffer,n,!0,(r==null?void 0:r.usages)||["encrypt"]);let c;return e.privateKey&&e.privateKey.length&&(c=await crypto.subtle.importKey("pkcs8",R("pem",e.privateKey).buffer,n,!0,(r==null?void 0:r.usages)||["decrypt"])),{algorithm:"RSA-OAEP",name:t,password:(r==null?void 0:r.password)||"none",publicKey:a,privateKey:c,creationDate:new Date,useDate:new Date}},async exportKey(e){if(e.type=="public"){const t=await crypto.subtle.exportKey("spki",e);return j+D(new Uint8Array(t))+V}else if(e.type=="private"){const t=await crypto.subtle.exportKey("pkcs8",e);return N+D(new Uint8Array(t))+G}throw new d("wrong_key","This algorithm doesn't support this key type.","RSA")},isCompatible(e,t){var r,n,a,c;switch(t){case"encrypt":case"verify":case"wrapKey":return(n=(r=e.publicKey)==null?void 0:r.usages.includes(t))!=null?n:!1;case"sign":case"decrypt":case"unwrapKey":return(c=(a=e.privateKey)==null?void 0:a.usages.includes(t))!=null?c:!1;default:return!1}}},ge=["decrypt","deriveBits","deriveKey","encrypt","sign","unwrapKey","verify","wrapKey"];let h;const O=new Map([["RSA-OAEP",we]]);async function be(e){if((h==null?void 0:h.keyId)==e)return h;let r=await(await g()).get("cryptoKeys",e);return r||(r=await me("RSA-OAEP","Test",{keyId:e})),h=r,r}async function Ae(e,t,r){const n=l(t.algorithm),c=new TextEncoder().encode(e),s=await n.encrypt(t,c,r);return W(t),D(s)}async function pe(e,t){const r=l(t.algorithm),n=new TextDecoder,a=await r.decrypt(t,U(e));return W(t),n.decode(a)}async function me(e,t,r){const n=l(e);console.info("Generate key");const a=await n.generateKey(t,r),c=await g();return a.keyId=await c.add("cryptoKeys",a),a}async function Ke(e,t,r,n){const a=l(e);console.info("Generate key");const c=await a.importKey(t,r,n),s=await g();return c.keyId=await s.add("cryptoKeys",c),c}function De(e,t){return l(e.algorithm).isCompatible(e,t)}function Ie(e){return ge.includes(e)}async function W(e){const t=await g();e.useDate=new Date,await t.put("cryptoKeys",e)}async function Se(e){return l(e.algorithm.name).exportKey(e)}function l(e){const t=O.get(e);if(!t)throw new d("algorithm_unknown",`The algorithm ${e} is unknown. Only ${Array.from(O.keys())} are valid.`);return t}export{De as a,me as b,Ke as c,be as d,pe as e,Ae as f,g,Se as h,Ie as i};
