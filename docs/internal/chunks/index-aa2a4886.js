var W=Object.defineProperty,Y=Object.defineProperties;var H=Object.getOwnPropertyDescriptors;var I=Object.getOwnPropertySymbols;var Z=Object.prototype.hasOwnProperty,J=Object.prototype.propertyIsEnumerable;var S=(e,t,r)=>t in e?W(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,M=(e,t)=>{for(var r in t||(t={}))Z.call(t,r)&&S(e,r,t[r]);if(I)for(var r of I(t))J.call(t,r)&&S(e,r,t[r]);return e},B=(e,t)=>Y(e,H(t));const Q=(e,t)=>t.some(r=>e instanceof r);let T,P;function X(){return T||(T=[IDBDatabase,IDBObjectStore,IDBIndex,IDBCursor,IDBTransaction])}function z(){return P||(P=[IDBCursor.prototype.advance,IDBCursor.prototype.continue,IDBCursor.prototype.continuePrimaryKey])}const O=new WeakMap,b=new WeakMap,C=new WeakMap,w=new WeakMap,K=new WeakMap;function q(e){const t=new Promise((r,n)=>{const a=()=>{e.removeEventListener("success",c),e.removeEventListener("error",s)},c=()=>{r(u(e.result)),a()},s=()=>{n(e.error),a()};e.addEventListener("success",c),e.addEventListener("error",s)});return t.then(r=>{r instanceof IDBCursor&&O.set(r,e)}).catch(()=>{}),K.set(t,e),t}function ee(e){if(b.has(e))return;const t=new Promise((r,n)=>{const a=()=>{e.removeEventListener("complete",c),e.removeEventListener("error",s),e.removeEventListener("abort",s)},c=()=>{r(),a()},s=()=>{n(e.error||new DOMException("AbortError","AbortError")),a()};e.addEventListener("complete",c),e.addEventListener("error",s),e.addEventListener("abort",s)});b.set(e,t)}let A={get(e,t,r){if(e instanceof IDBTransaction){if(t==="done")return b.get(e);if(t==="objectStoreNames")return e.objectStoreNames||C.get(e);if(t==="store")return r.objectStoreNames[1]?void 0:r.objectStore(r.objectStoreNames[0])}return u(e[t])},set(e,t,r){return e[t]=r,!0},has(e,t){return e instanceof IDBTransaction&&(t==="done"||t==="store")?!0:t in e}};function te(e){A=e(A)}function re(e){return e===IDBDatabase.prototype.transaction&&!("objectStoreNames"in IDBTransaction.prototype)?function(t,...r){const n=e.call(g(this),t,...r);return C.set(n,t.sort?t.sort():[t]),u(n)}:z().includes(e)?function(...t){return e.apply(g(this),t),u(O.get(this))}:function(...t){return u(e.apply(g(this),t))}}function ne(e){return typeof e=="function"?re(e):(e instanceof IDBTransaction&&ee(e),Q(e,X())?new Proxy(e,A):e)}function u(e){if(e instanceof IDBRequest)return q(e);if(w.has(e))return w.get(e);const t=ne(e);return t!==e&&(w.set(e,t),K.set(t,e)),t}const g=e=>K.get(e);function ae(e,t,{blocked:r,upgrade:n,blocking:a,terminated:c}={}){const s=indexedDB.open(e,t),o=u(s);return n&&s.addEventListener("upgradeneeded",i=>{n(u(s.result),i.oldVersion,i.newVersion,u(s.transaction))}),r&&s.addEventListener("blocked",()=>r()),o.then(i=>{c&&i.addEventListener("close",()=>c()),a&&i.addEventListener("versionchange",()=>a())}).catch(()=>{}),o}const ce=["get","getKey","getAll","getAllKeys","count"],se=["put","add","delete","clear"],m=new Map;function L(e,t){if(!(e instanceof IDBDatabase&&!(t in e)&&typeof t=="string"))return;if(m.get(t))return m.get(t);const r=t.replace(/FromIndex$/,""),n=t!==r,a=se.includes(r);if(!(r in(n?IDBIndex:IDBObjectStore).prototype)||!(a||ce.includes(r)))return;const c=async function(s,...o){const i=this.transaction(s,a?"readwrite":"readonly");let y=i.store;return n&&(y=y.index(o.shift())),(await Promise.all([y[r](...o),a&&i.done]))[0]};return m.set(t,c),c}te(e=>B(M({},e),{get:(t,r,n)=>L(t,r)||e.get(t,r,n),has:(t,r)=>!!L(t,r)||e.has(t,r)}));const oe=1;let E;async function D(){return E||(E=await ae("crypto-db",oe,{upgrade(e,t){t<1&&e.createObjectStore("cryptoKeys",{keyPath:"keyId",autoIncrement:!0})}})),E}function ie(e){return e>64&&e<91?e-65:e>96&&e<123?e-71:e>47&&e<58?e+4:e===43?62:e===47?63:0}function _(e,t){const r=e.replace(/[^A-Za-z0-9+/]/g,""),n=r.length,a=t?Math.ceil((n*3+1>>2)/t)*t:n*3+1>>2,c=new Uint8Array(a);for(let s,o,i=0,y=0,f=0;f<n;f++)if(o=f&3,i|=ie(r.charCodeAt(f))<<6*(3-o),o===3||n-f===1){for(s=0;s<3&&y<a;s++,y++)c[y]=i>>>(16>>>s&24)&255;i=0}return c}function h(e){return e<26?e+65:e<52?e+71:e<62?e-4:e===62?43:e===63?47:65}function p(e){let t=2,r="";for(let n=e.length,a=0,c=0;c<n;c++)t=c%3,c>0&&c*4/3%76===0&&(r+=`\r
`),a|=e[c]<<(16>>>t&24),(t===2||e.length-c===1)&&(r+=String.fromCodePoint(h(a>>>18&63),h(a>>>12&63),h(a>>>6&63),h(a&63)),a=0);return r.substr(0,r.length-2+t)+(t===2?"":t===1?"=":"==")}class d extends Error{constructor(t,r,n){super((n?n+" - ":"")+t+" - "+r),this.name="CryptoError"}}const U=`-----BEGIN PRIVATE KEY-----
`,N=`
-----END PRIVATE KEY-----`,G=`-----BEGIN PUBLIC KEY-----
`,j=`
-----END PUBLIC KEY-----`;function v(e,t,r){if(!e)throw new d("wrong_key",`${r} does not support this type of key for ${t}.`,r);if(e.algorithm.name!=r)throw new d("wrong_key",`This key isn't made for ${r} but for ${e.algorithm.name}.`);if(!e.usages.includes(t))throw new d("wrong_key_usage",`This key does not support ${t}.`,r);return e}function k(e,t,...r){const n=Math.ceil(t/8),a=[];for(let o=0;o<n;o++)a.push(e>>8*o&255);const c=V(...r),s=new Uint8Array(c.length+n);return s.set(a),s.set(c,n),s}function V(...e){const t=e.reduce((a,c)=>a+c.length+Math.ceil(ye(c.length)/7),0),r=new Uint8Array(t);let n=0;for(const a of e){let c=a.length;const s=[];do{let o=c&127;c>>=7,c>0&&(o|=128),s.push(o)}while(c>0);r.set(s,n),n+=s.length,r.set(a,n),n+=a.length}return console.assert(n==t,"We should have added the whole length",{offset:n,length:t,arrays:e}),r}function ue(e,t){const r=Math.ceil(e/8);let n=0;for(let c=0;c<r;c++){const s=t.at(c);!s||(n|=s<<8*c)}const a=$(t.slice(r));return{flags:n,arrays:a}}function $(e){const t=[];let r=0;for(;r<e.length;){let n=0,a,c=0;do{if(a=e.at(r),r+=1,!a)break;n|=(a&127)<<7*c++}while((a&128)==128);if(n+r>e.length)break;t.push(e.slice(r,r+n)),r+=n}if(r!=e.length)throw new d("malformed_data","The data to split is malformed.");return t}function ye(e){return e?Math.floor(Math.log2(e)+1):1}function x(e,t){const r=e=="pem"?U.trim():G.trim(),n=e=="pem"?N.trim():j.trim(),a=t.search(r),c=t.search(n);if(a<0||c<0)throw new d("malformed_data",`The key given is malformed and does not meet the requirements of ${e} encoding.`);return _(t.substring(a+r.length,c))}async function de(e,t,r){const n=crypto.getRandomValues(new Uint8Array(Math.ceil(r/8))),a=await crypto.subtle.importKey("raw",n.buffer,t,!1,[e]);return{key:n,keyEncoded:a}}async function le(e,t){const{key:r,keyEncoded:n}=await de("encrypt",(t==null?void 0:t.name)||"AES-GCM",(t==null?void 0:t.keyLength)||256),a=crypto.getRandomValues(new Uint8Array(Math.ceil(t!=null&&t.keyLength?t.keyLength/8:32))),c=(t==null?void 0:t.name)=="AES-CTR"?{name:"AES-CTR",counter:a,length:t!=null&&t.length?t==null?void 0:t.length:64}:{name:(t==null?void 0:t.name)||"AES-GCM",iv:a},s=new Uint8Array(await crypto.subtle.encrypt(c,n,e)),o=V(a,s);return{key:r,cipher:o}}async function fe(e,t){const r=await crypto.subtle.importKey("raw",e.buffer,"AES-GCM",!1,["decrypt"]),[n,a]=$(t);return new Uint8Array(await crypto.subtle.decrypt({name:"AES-GCM",iv:n},r,a))}const he={async encrypt(e,t,r){const n=v(e.publicKey,"encrypt","RSA-OAEP");if((r==null?void 0:r.useSubEncrypt)==null&&(r||(r={}),r.useSubEncrypt=!!r.subEncrypt||t.length>32),r.useSubEncrypt){r.subEncrypt||(r.subEncrypt={name:"AES-GCM"});const{key:a,cipher:c}=await le(t,r.subEncrypt),s=await crypto.subtle.encrypt(n.algorithm,n,a);return k(1,1,new Uint8Array(s),c)}else{const a=await crypto.subtle.encrypt(n.algorithm,n,t);return k(0,1,new Uint8Array(a))}},async decrypt(e,t){const r=v(e.privateKey,"decrypt","RSA-OAEP"),{flags:n,arrays:a}=ue(1,t);if(n==1){const[c,s]=a,o=new Uint8Array(await crypto.subtle.decrypt(r.algorithm,r,c));return fe(o,s)}else{const[c]=a;return new Uint8Array(await crypto.subtle.decrypt(r.algorithm,r,c))}},async generateKey(e,t){const r=await crypto.subtle.generateKey({name:"RSA-OAEP",modulusLength:(t==null?void 0:t.modulus)||4096,publicExponent:new Uint8Array([1,0,1]),hash:(t==null?void 0:t.hash)||"SHA-256"},!0,(t==null?void 0:t.usages)||["encrypt","decrypt"]);return{algorithm:"RSA-OAEP",name:e,password:(t==null?void 0:t.password)||"none",privateKey:r.privateKey,publicKey:r.publicKey,creationDate:new Date,useDate:new Date}},async importKey(e,t,r){const n={name:"RSA-OAEP",modulusLength:(r==null?void 0:r.modulus)||4096,publicExponent:new Uint8Array([1,0,1]),hash:(r==null?void 0:r.hash)||"SHA-256"},a=await crypto.subtle.importKey("spki",x("spki",e.key).buffer,n,!0,(r==null?void 0:r.usages)||["encrypt"]);let c;return e.privateKey&&e.privateKey.length&&(c=await crypto.subtle.importKey("pkcs8",x("pem",e.privateKey).buffer,n,!0,(r==null?void 0:r.usages)||["decrypt"])),{algorithm:"RSA-OAEP",name:t,password:(r==null?void 0:r.password)||"none",publicKey:a,privateKey:c,creationDate:new Date,useDate:new Date}},async exportKey(e){if(e.type=="public"){const t=await crypto.subtle.exportKey("spki",e);return G+p(new Uint8Array(t))+j}else if(e.type=="private"){const t=await crypto.subtle.exportKey("pkcs8",e);return U+p(new Uint8Array(t))+N}throw new d("wrong_key","This algorithm doesn't support this key type.","RSA")},isCompatible(e,t){var r,n,a,c;switch(t){case"encrypt":case"verify":case"wrapKey":return(n=(r=e.publicKey)==null?void 0:r.usages.includes(t))!=null?n:!1;case"sign":case"decrypt":case"unwrapKey":return(c=(a=e.privateKey)==null?void 0:a.usages.includes(t))!=null?c:!1;default:return!1}}},we=["decrypt","deriveBits","deriveKey","encrypt","sign","unwrapKey","verify","wrapKey"],R=new Map([["RSA-OAEP",he]]);async function me(e,t,r){const n=l(t.algorithm),c=new TextEncoder().encode(e),s=await n.encrypt(t,c,r);return F(t),p(s)}async function Ee(e,t){const r=l(t.algorithm),n=new TextDecoder,a=await r.decrypt(t,_(e));return F(t),n.decode(a)}async function be(e,t,r){const n=l(e);console.info("Generate key");const a=await n.generateKey(t,r),c=await D();return a.keyId=await c.add("cryptoKeys",a),a}async function Ae(e,t,r,n){const a=l(e);console.info("Generate key");const c=await a.importKey(t,r,n),s=await D();return c.keyId=await s.add("cryptoKeys",c),c}function pe(e,t){return l(e.algorithm).isCompatible(e,t)}function Ke(e){return we.includes(e)}async function F(e){const t=await D();e.useDate=new Date,await t.put("cryptoKeys",e)}async function De(e){return l(e.algorithm.name).exportKey(e)}function l(e){const t=R.get(e);if(!t)throw new d("algorithm_unknown",`The algorithm ${e} is unknown. Only ${Array.from(R.keys())} are valid.`);return t}export{pe as a,be as b,Ae as c,Ee as d,me as e,De as f,D as g,Ke as i};
